#!/usr/bin/env node

/**
 * Test de la g√©n√©ration temps r√©el et des performances
 * Test du debouncing et de la responsivit√© de l'interface
 */

const path = require('path');

// Simulation des types TypeScript
const DEFAULT_CHILD_PROFILE = {
  gender: 'unisex',
  hairType: 'short01',
  hairColor: '6d4c41',
  skinTone: 'e0ac69',
  eyes: 'variant01',
  eyebrows: 'variant01',
  mouth: 'variant01',
  earrings: 'variant01',
  glasses: 'variant01',
  features: 'blush'
};

// Fonctions de conversion simul√©es
function convertProfileToAvatarConfig(profile) {
  const config = {
    hair: [profile.hairType],
    hairColor: [profile.hairColor],
    skinColor: [profile.skinTone],
    eyes: [profile.eyes],
    eyebrows: [profile.eyebrows],
    mouth: [profile.mouth],
    earrings: [profile.earrings],
    glasses: [profile.glasses],
    features: [profile.features],
    backgroundColor: ['b6e3f4']
  };
  
  return config;
}

function validateAndCleanConfig(config) {
  const cleanedConfig = {};
  
  for (const [key, value] of Object.entries(config)) {
    if (Array.isArray(value) && value.length > 0) {
      const validValues = Array.from(new Set(
        value.filter(v => typeof v === 'string' && v.trim() !== '')
      ));
      
      if (validValues.length > 0) {
        if (key === 'base' && validValues[0] !== 'default') {
          continue;
        }
        cleanedConfig[key] = validValues;
      }
    }
  }
  
  if (!cleanedConfig.backgroundColor) {
    cleanedConfig.backgroundColor = ['b6e3f4'];
  }
  
  return cleanedConfig;
}

// Simulation de g√©n√©ration d'avatar (sans DiceBear pour la d√©mo)
function simulateAvatarGeneration(config, callback) {
  return new Promise((resolve) => {
    const startTime = Date.now();
    
    // Simulation du progr√®s
    let progress = 0;
    const progressInterval = setInterval(() => {
      progress += 0.1;
      callback?.(Math.min(progress, 0.9));
      
      if (progress >= 1) {
        clearInterval(progressInterval);
        const generationTime = Date.now() - startTime;
        resolve({
          dataUri: `data:image/svg+xml;base64,${Buffer.from(`Avatar g√©n√©r√© en ${generationTime}ms`).toString('base64')}`,
          generationTime,
          config
        });
      }
    }, 50);
  });
}

// Syst√®me de debouncing optimis√©
function createAvatarDebounce(delay = 250) {
  let timeoutId;
  let lastCallTime = 0;
  
  return function debounce(callback, config) {
    const now = Date.now();
    const timeSinceLastCall = now - lastCallTime;
    
    clearTimeout(timeoutId);
    
    if (timeSinceLastCall >= delay) {
      lastCallTime = now;
      callback(config);
    } else {
      timeoutId = setTimeout(() => {
        lastCallTime = Date.now();
        callback(config);
      }, delay - timeSinceLastCall);
    }
  };
}

async function testRealTimeGeneration() {
  console.log('‚ö° TEST G√âN√âRATION TEMPS R√âEL AVATAR');
  console.log('‚ïê'.repeat(80));
  
  const debounce = createAvatarDebounce(250);
  const changes = [];
  const results = [];
  
  // TEST 1: Debouncing sur modifications rapides
  console.log('\nüöÄ TEST 1: Debouncing sur modifications rapides');
  console.log('‚îÄ'.repeat(60));
  
  const testConfigs = [
    { ...DEFAULT_CHILD_PROFILE, gender: 'boy', hairType: 'short01' },
    { ...DEFAULT_CHILD_PROFILE, gender: 'girl', hairType: 'long01' },
    { ...DEFAULT_CHILD_PROFILE, hairColor: 'f5c842' },
    { ...DEFAULT_CHILD_PROFILE, skinTone: 'fdbcb4' },
    { ...DEFAULT_CHILD_PROFILE, eyes: 'variant05' }
  ];
  
  const startTestTime = Date.now();
  
  // Simuler des changements rapides (tous les 100ms)
  for (let i = 0; i < testConfigs.length; i++) {
    const config = testConfigs[i];
    changes.push({
      index: i,
      config,
      timestamp: Date.now() - startTestTime
    });
    
    debounce((cfg) => {
      const changeStartTime = Date.now();
      simulateAvatarGeneration(convertProfileToAvatarConfig(cfg), (progress) => {
        // Callback de progr√®s
      }).then(result => {
        results.push({
          changeIndex: i,
          config: cfg,
          result,
          responseTime: Date.now() - changeStartTime,
          changeTime: Date.now() - startTestTime
        });
        
        console.log(`  ‚úÖ Changement ${i + 1}: ${cfg.gender} ${cfg.hairType} - ${result.generationTime}ms`);
      });
    }, config);
    
    // Attendre 100ms entre chaque changement
    await new Promise(resolve => setTimeout(resolve, 100));
  }
  
  // Attendre que tous les debouncing se terminent
  await new Promise(resolve => setTimeout(resolve, 500));
  
  const totalTestTime = Date.now() - startTestTime;
  
  // TEST 2: Analyse des performances
  console.log('\nüìä TEST 2: Analyse des performances');
  console.log('‚îÄ'.repeat(60));
  
  const generationTimes = results.map(r => r.result.generationTime);
  const responseTimes = results.map(r => r.responseTime);
  
  const avgGenerationTime = generationTimes.reduce((a, b) => a + b, 0) / generationTimes.length;
  const avgResponseTime = responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length;
  const maxGenerationTime = Math.max(...generationTimes);
  const maxResponseTime = Math.max(...responseTimes);
  
  console.log(`  ‚ö° Temps moyen de g√©n√©ration: ${avgGenerationTime.toFixed(2)}ms`);
  console.log(`  ‚ö° Temps moyen de r√©ponse: ${avgResponseTime.toFixed(2)}ms`);
  console.log(`  üêå Temps max de g√©n√©ration: ${maxGenerationTime}ms`);
  console.log(`  üêå Temps max de r√©ponse: ${maxResponseTime}ms`);
  console.log(`  ‚è±Ô∏è Dur√©e totale du test: ${totalTestTime}ms`);
  
  // TEST 3: Test de valid√© de configuration
  console.log('\n‚öôÔ∏è TEST 3: Validation et nettoyage de configuration');
  console.log('‚îÄ'.repeat(60));
  
  const invalidConfigs = [
    { hair: [], hairColor: [''], skinColor: ['invalid'] },
    { hair: [''], hairColor: ['f5c842', '6d4c41'], skinColor: [] },
    { base: ['invalid'], backgroundColor: [] }
  ];
  
  invalidConfigs.forEach((config, index) => {
    const cleaned = validateAndCleanConfig(config);
    console.log(`  ${index + 1}. Config ${index + 1}:`);
    console.log(`     Entrant: ${JSON.stringify(config)}`);
    console.log(`     Nettoy√©: ${JSON.stringify(cleaned)}`);
    
    const isValid = cleaned.backgroundColor && cleaned.backgroundColor.length > 0;
    console.log(`     ${isValid ? '‚úÖ' : '‚ùå'} Validation: ${isValid ? 'R√©ussie' : '√âchou√©e'}`);
  });
  
  // TEST 4: Test de charge (modifications simultan√©es)
  console.log('\nüî• TEST 4: Test de charge - Modifications simultan√©es');
  console.log('‚îÄ'.repeat(60));
  
  const loadTestStart = Date.now();
  const loadTestPromises = [];
  
  // Simuler 10 modifications simultan√©es
  for (let i = 0; i < 10; i++) {
    const config = {
      ...DEFAULT_CHILD_PROFILE,
      gender: i % 2 === 0 ? 'boy' : 'girl',
      hairType: i % 3 === 0 ? 'short01' : 'long01',
      hairColor: ['6d4c41', 'f5c842', 'e67e22'][i % 3]
    };
    
    const promise = simulateAvatarGeneration(convertProfileToAvatarConfig(config))
      .then(result => ({
        index: i,
        config,
        result,
        time: Date.now() - loadTestStart
      }));
    
    loadTestPromises.push(promise);
  }
  
  const loadResults = await Promise.all(loadTestPromises);
  const loadTestTime = Date.now() - loadTestStart;
  
  console.log(`  ‚ö° Test de charge termin√© en: ${loadTestTime}ms`);
  console.log(`  üìä G√©n√©rations parall√®les: ${loadResults.length}`);
  console.log(`  üèÅ Toutes les g√©n√©rations compl√©t√©es: ${loadResults.every(r => r.result) ? '‚úÖ' : '‚ùå'}`);
  
  // R√âSUM√â FINAL
  console.log('\nüìä R√âSUM√â DES PERFORMANCES');
  console.log('‚ïê'.repeat(80));
  
  const allTestsPassed = 
    avgGenerationTime < 500 && 
    maxGenerationTime < 1000 &&
    totalTestTime < 2000 &&
    loadTestTime < 1500;
  
  if (allTestsPassed) {
    console.log('üéâ SUCC√àS: Performances excellentes!');
    console.log(`‚úÖ Debouncing: ${delay}ms (optimis√©)`);
    console.log(`‚úÖ G√©n√©ration temps r√©el: ${avgGenerationTime.toFixed(2)}ms`);
    console.log(`‚úÖ Gestion de charge: 10 g√©n√©rations en ${loadTestTime}ms`);
    console.log(`‚úÖ Interface responsive: ${avgResponseTime.toFixed(2)}ms`);
    return true;
  } else {
    console.log('‚ö†Ô∏è PERFORMANCE D√âGRAD√âE: Optimisations recommand√©es');
    console.log(`‚ùå Temps de g√©n√©ration: ${avgGenerationTime.toFixed(2)}ms (objectif: <500ms)`);
    console.log(`‚ùå Temps de r√©ponse: ${avgResponseTime.toFixed(2)}ms (objectif: <300ms)`);
    return false;
  }
}

// Lancer les tests
const delay = process.argv[2] ? parseInt(process.argv[2]) : 250;

(async () => {
  try {
    const success = await testRealTimeGeneration();
    console.log(`\nüèÅ Test termin√© avec ${success ? 'SUCC√àS' : 'DES PROBL√àMES DE PERFORMANCE'}`);
    process.exit(success ? 0 : 1);
  } catch (error) {
    console.error('üí• Erreur lors du test:', error.message);
    process.exit(1);
  }
})();